name: Beaker Experiment Launch

on:
  merge_group:

  # Adding a comment to trigger a run.
  workflow_dispatch:  # This allows us to manually trigger a build through the GitHub UI.
  # pull_request:
  #   branches: [main]
  #   paths:
  #     - 'open_instruct/**'
  #     - '!open_instruct/README.md'
  #     - 'requirements.txt'
  #     - 'Dockerfile'
  #     - '.github/workflows/beaker-experiment.yml'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  DOCKER_BUILDKIT: "1"

jobs:
  launch-experiment:
    name: Launch Beaker Experiment
    runs-on: 8-Core-XL-Runner-Ubuntu-Latest
    timeout-minutes: 35

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history to get commit author info

      - name: Checkout oe-eval-internal
        uses: actions/checkout@v4
        with:
          repository: allenai/oe-eval-internal
          path: './oe-eval-internal'
          ssh-key: ${{ secrets.OE_EVAL_GIT_CLONE_ACCESS_PRIVATE_SSH_DEPLOY_KEY }}
          fetch-depth: 1
          filter: 'blob:none'

      - name: Get trigger information
        id: get-trigger-info
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # Get the commit author for push events
            AUTHOR_NAME=$(git log -1 --pretty=format:'%an')
            echo "trigger_info=Push by ${AUTHOR_NAME}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Get the user who triggered the manual dispatch
            echo "trigger_info=Manual dispatch by ${{ github.actor }}" >> $GITHUB_OUTPUT
          else
            # For scheduled runs
            echo "trigger_info=Scheduled run" >> $GITHUB_OUTPUT
          fi

      - name: Get changed files using git diff
        id: changed-files
        run: |
          COMMON_ANCESTOR=$(git merge-base HEAD origin/main)

          CHANGED_FILES=$(git diff --name-only ${COMMON_ANCESTOR} HEAD)
          printf 'Changed files:\n%s\n' "$CHANGED_FILES"

          declare -A CHANGE_PATTERNS=(
            [dpo_changed]="open_instruct/(dpo_tune_cache|dpo_utils)\.py"
            [finetune_changed]="open_instruct/finetune\.py"
            [grpo_changed]="(^|/)Dockerfile$|(^|/)mason\.py$|^open_instruct/"
          )

          for OUTPUT_KEY in dpo_changed finetune_changed grpo_changed; do
            PATTERN="${CHANGE_PATTERNS[$OUTPUT_KEY]}"
            MATCHED=$(grep -qE "$PATTERN" <<< "$CHANGED_FILES" && echo true || echo false)
            echo "${OUTPUT_KEY}=${MATCHED}" >> "$GITHUB_OUTPUT"
          done

      - name: Setup Python environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install uv
        uses: astral-sh/setup-uv@v3

      - name: Setup Beaker
        uses: allenai/setup-beaker@v2
        with:
          token: ${{ secrets.BEAKER_TOKEN }}
          workspace: ai2/open-instruct-dev

      - name: Install dependencies
        run: |
          # Install development dependencies needed for mason.py
          uv sync --frozen

      - name: Build image and launch experiments
        id: launch
        env:
          BEAKER_TOKEN: ${{ secrets.BEAKER_TOKEN }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          DPO_CHANGED: ${{ steps.changed-files.outputs.dpo_changed }}
          FINETUNE_CHANGED: ${{ steps.changed-files.outputs.finetune_changed }}
          GRPO_CHANGED: ${{ steps.changed-files.outputs.grpo_changed }}
        run: |
          set -euo pipefail

          chmod +x scripts/train/build_image_and_launch.sh scripts/train/debug/*.sh

          echo "Building Docker image and launching experiments..."
          echo "Git commit: $(git rev-parse --short HEAD)"

          EXPERIMENT_IDS=()
          EXPERIMENT_NAMES=()

          launch_and_capture() {
            local SCRIPT_PATH="$1"
            local EXPERIMENT_NAME="$2"
            local LOG_FILE="/tmp/beaker_output_${EXPERIMENT_NAME}.log"

            if ! ./scripts/train/build_image_and_launch.sh "$SCRIPT_PATH" 2>&1 | tee "$LOG_FILE"; then
              local EXIT_CODE=${PIPESTATUS[0]}
              echo "ERROR: ${EXPERIMENT_NAME}.sh failed with exit code $EXIT_CODE"
              return $EXIT_CODE
            fi

            local EXPERIMENT_ID
            EXPERIMENT_ID=$(grep -oP 'https://beaker.org/ex/\K[a-zA-Z0-9]+' "$LOG_FILE" | tail -1)
            if [ -z "$EXPERIMENT_ID" ]; then
              echo "ERROR: Failed to extract experiment ID from ${EXPERIMENT_NAME}.sh output"
              echo "DEBUG: Full output log:"
              cat "$LOG_FILE"
              echo "---"
              echo "Please check that the experiment was created successfully."
              return 1
            fi

            EXPERIMENT_IDS+=("$EXPERIMENT_ID")
            EXPERIMENT_NAMES+=("$EXPERIMENT_NAME")
            echo "Launched ${EXPERIMENT_NAME} experiment: $EXPERIMENT_ID"
          }

          EXPERIMENT_DEFINITIONS=(
            "single_gpu_on_beaker|scripts/train/debug/single_gpu_on_beaker.sh|always|Launching single_gpu_on_beaker.sh (always runs)"
            "grpo|scripts/train/debug/grpo.sh|${GRPO_CHANGED}|Launching grpo.sh (core files changed)"
            "dpo|scripts/train/debug/dpo.sh|${DPO_CHANGED}|Launching dpo.sh (DPO files changed)"
            "finetune|scripts/train/debug/finetune.sh|${FINETUNE_CHANGED}|Launching finetune.sh (finetune.py changed)"
          )

          for DEFINITION in "${EXPERIMENT_DEFINITIONS[@]}"; do
            IFS='|' read -r EXP_NAME EXP_SCRIPT EXP_CONDITION EXP_MESSAGE <<< "$DEFINITION"
            if [ "$EXP_CONDITION" != "true" ] && [ "$EXP_CONDITION" != "always" ]; then
              echo "Skipping ${EXP_NAME} experiment (condition not met)"
              continue
            fi

            echo "=== ${EXP_MESSAGE} ==="
            if ! launch_and_capture "$EXP_SCRIPT" "$EXP_NAME"; then
              EXIT_CODE=$?
              exit $EXIT_CODE
            fi
          done

          if [ ${#EXPERIMENT_IDS[@]} -eq 0 ]; then
            echo "ERROR: No experiments were launched."
            exit 1
          fi

          GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          SANITIZED_BRANCH=$(echo "$GIT_BRANCH" | sed 's/[^a-zA-Z0-9._-]/-/g' | tr '[:upper:]' '[:lower:]' | sed 's/^-//')
          INTEGRATION_IMAGE="open-instruct-integration-test-${SANITIZED_BRANCH}"
          echo "Integration image tag: ${INTEGRATION_IMAGE}"

          if ! docker image inspect "$INTEGRATION_IMAGE" >/dev/null 2>&1; then
            echo "Local image ${INTEGRATION_IMAGE} not found; attempting to pull from Beaker."
            BEAKER_USER=$(beaker account whoami --format json | jq -r '.[0].name')
            if beaker image pull "$BEAKER_USER/$INTEGRATION_IMAGE"; then
              for CANDIDATE in "$BEAKER_USER/$INTEGRATION_IMAGE" "ai2/$BEAKER_USER/$INTEGRATION_IMAGE"; do
                if docker image inspect "$CANDIDATE" >/dev/null 2>&1; then
                  docker tag "$CANDIDATE" "$INTEGRATION_IMAGE"
                  break
                fi
              done
            else
              echo "ERROR: Unable to pull ${BEAKER_USER}/${INTEGRATION_IMAGE} from Beaker."
              exit 1
            fi
          fi

          if ! docker image inspect "$INTEGRATION_IMAGE" >/dev/null 2>&1; then
            echo "ERROR: Integration image ${INTEGRATION_IMAGE} unavailable locally after build/pull."
            exit 1
          fi

          echo "experiment_ids=${EXPERIMENT_IDS[*]}" >> $GITHUB_OUTPUT
          echo "experiment_names=${EXPERIMENT_NAMES[*]}" >> $GITHUB_OUTPUT
          echo "integration_image=${INTEGRATION_IMAGE}" >> $GITHUB_OUTPUT
          echo "All experiments launched successfully!"
          echo "Experiment IDs: ${EXPERIMENT_IDS[*]}"

      - name: Wait for all Beaker experiments completion
        env:
          BEAKER_TOKEN: ${{ secrets.BEAKER_TOKEN }}
        run: |
          set -euo pipefail

          EXPERIMENT_IDS=(${{ steps.launch.outputs.experiment_ids }})
          EXPERIMENT_NAMES=(${{ steps.launch.outputs.experiment_names }})

          if [ ${#EXPERIMENT_IDS[@]} -eq 0 ]; then
            echo "No experiments detected; nothing to wait for."
            exit 0
          fi

          echo "Waiting for ${#EXPERIMENT_IDS[@]} experiments to complete..."
          for i in "${!EXPERIMENT_IDS[@]}"; do
            echo "  - ${EXPERIMENT_NAMES[$i]}: ${EXPERIMENT_IDS[$i]} (https://beaker.org/ex/${EXPERIMENT_IDS[$i]})"
          done

          MAX_WAIT_TIME=1200
          CHECK_INTERVAL=30
          ELAPSED_TIME=0

          declare -A EXPERIMENT_STATUS
          for EXP_ID in "${EXPERIMENT_IDS[@]}"; do
            EXPERIMENT_STATUS[$EXP_ID]="running"
          done

          get_exit_code() {
            local EXP_ID="$1"
            local RESPONSE EXIT_CODE

            if ! RESPONSE=$(beaker experiment get "$EXP_ID" --format json 2>/dev/null); then
              echo "pending"
              return
            fi

            EXIT_CODE=$(echo "$RESPONSE" | jq -r '.[0].jobs[0].status.exitCode // "pending"' 2>/dev/null || echo "pending")
            EXIT_CODE=${EXIT_CODE:-pending}
            if [ "$EXIT_CODE" = "null" ]; then
              echo "pending"
            else
              echo "$EXIT_CODE"
            fi
          }

          ANY_FAILED=false

          while [ $ELAPSED_TIME -lt $MAX_WAIT_TIME ]; do
            echo "=== Check at ${ELAPSED_TIME}s ==="

            ALL_DONE=true

            for i in "${!EXPERIMENT_IDS[@]}"; do
              EXP_ID="${EXPERIMENT_IDS[$i]}"
              EXP_NAME="${EXPERIMENT_NAMES[$i]}"

              if [ "${EXPERIMENT_STATUS[$EXP_ID]}" != "running" ]; then
                continue
              fi

              EXIT_CODE=$(get_exit_code "$EXP_ID")

              case "$EXIT_CODE" in
                pending)
                  echo "  [$EXP_NAME] Still running..."
                  ALL_DONE=false
                  ;;
                0)
                  echo "  [$EXP_NAME] ✅ Completed successfully (exit code: 0)"
                  EXPERIMENT_STATUS[$EXP_ID]="success"
                  ;;
                *)
                  echo "  [$EXP_NAME] ❌ Failed with exit code: $EXIT_CODE"
                  EXPERIMENT_STATUS[$EXP_ID]="failed"
                  ANY_FAILED=true
                  ALL_DONE=false
                  ;;
              esac
            done

            if $ALL_DONE; then
              echo ""
              echo "=== All experiments completed ==="
              for i in "${!EXPERIMENT_IDS[@]}"; do
                EXP_ID="${EXPERIMENT_IDS[$i]}"
                EXP_NAME="${EXPERIMENT_NAMES[$i]}"
                STATUS="${EXPERIMENT_STATUS[$EXP_ID]}"
                echo "  [$EXP_NAME] $STATUS"
              done

              if $ANY_FAILED; then
                echo ""
                echo "❌ One or more experiments failed. Showing error logs:"
                for i in "${!EXPERIMENT_IDS[@]}"; do
                  EXP_ID="${EXPERIMENT_IDS[$i]}"
                  EXP_NAME="${EXPERIMENT_NAMES[$i]}"
                  if [ "${EXPERIMENT_STATUS[$EXP_ID]}" = "failed" ]; then
                    echo ""
                    echo "=== Error logs for $EXP_NAME (${EXP_ID}) ==="
                    beaker experiment logs "$EXP_ID" | tail -n 200
                  fi
                done
                exit 1
              fi

              echo ""
              echo "✅ All experiments completed successfully!"
              exit 0
            fi

            sleep "$CHECK_INTERVAL"
            ELAPSED_TIME=$((ELAPSED_TIME + CHECK_INTERVAL))
          done

          echo ""
          echo "⏱️ Timeout: Not all experiments completed within 20 minutes"
          echo "Final status:"
          for i in "${!EXPERIMENT_IDS[@]}"; do
            EXP_ID="${EXPERIMENT_IDS[$i]}"
            EXP_NAME="${EXPERIMENT_NAMES[$i]}"
            echo "  [$EXP_NAME] ${EXPERIMENT_STATUS[$EXP_ID]}"
          done
          exit 1

      - name: Check image
        run: docker run --rm ${{ steps.launch.outputs.integration_image }}

      - name: Push image to Beaker
        env:
          BEAKER_TARGET_IMAGE: open_instruct_auto
          SOURCE_IMAGE: ${{ steps.launch.outputs.integration_image }}
        run: |
          set -euo pipefail

          SHORT_SHA=$(git rev-parse --short HEAD)
          DESCRIPTION="Created from commit: ${SHORT_SHA} (GitHub run ${GITHUB_RUN_ID})"
          BEAKER_USER=$(beaker account whoami --format json | jq -r '.[0].name')

          echo "Renaming ${BEAKER_USER}/${BEAKER_TARGET_IMAGE} to release prior alias (if present)."
          beaker image rename "${BEAKER_USER}/${BEAKER_TARGET_IMAGE}" "" || true

          echo "Publishing ${BEAKER_TARGET_IMAGE} with updated image and description."
          beaker image create --name "$BEAKER_TARGET_IMAGE" --description "$DESCRIPTION" "$SOURCE_IMAGE"

      - name: Summary
        if: always()
        run: |
          echo "## Beaker Experiment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ steps.get-trigger-info.outputs.trigger_info }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Experiments Launched:" >> $GITHUB_STEP_SUMMARY

          EXPERIMENT_IDS=(${{ steps.launch.outputs.experiment_ids }})
          EXPERIMENT_NAMES=(${{ steps.launch.outputs.experiment_names }})

          for i in "${!EXPERIMENT_IDS[@]}"; do
            EXP_ID="${EXPERIMENT_IDS[$i]}"
            EXP_NAME="${EXPERIMENT_NAMES[$i]}"
            echo "- **$EXP_NAME**: [View on Beaker](https://beaker.org/ex/$EXP_ID)" >> $GITHUB_STEP_SUMMARY
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" = "success" ]; then
            echo "✅ **Status:** All experiments completed successfully and image pushed!" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Status:** Experiments failed or timed out (image not pushed)" >> $GITHUB_STEP_SUMMARY
          fi
